---
layout: post
title: "[QnA] 트랜잭션"
categories: Database
author: bn-tw2020
---
* content
{:toc}


## 트랜잭션

* 여러 쿼리를 논리적으로 하나의 작업을 묶는 것입니다.





## 예시 설명

* 거래가 일어날 때 실행되는 쿼리

* UPDATE문 : 구매자 계좌에서 1000원 빼기  
  UPDATE문 : 판매자 계좌에서 1000원 더하기  
  중간에서 서버 다운 등의 오류로 인해 계좌에서 돈이 빠졌는데 판매자의 계좌에는 돈이 입금되지 않는 형태가 발생할 수 있게 됩니다.

* 이런 상황을 방지하기 위해서 나온 것이 트랜잭션입니다. 그래서 논리적인 하나의 작업 단위로 묶어서 쿼리들이 한꺼번에 모두 실행되거나 아무 쿼리도 실행되지 않도록 하는 것입니다.
=> commit / rollback 이라고 부릅니다.  

* commit은 일종의 확인 도장으로 트랜잭션으로 묶인 모든 쿼리가 성공되어 트랜잭션 쿼리 결과를 실제 디비에 반영하는 것  

* rollback은 쿼리 실행 결과를 취소하고 디비를 트랜잭션 이전 상태로 돌리는 것

* 트랜잭션은 사용자 혹은 시스템 상의 실수가 있더라도 데이터를 안정적으로 보장할 수 있도록 합니다.


## ACID (트랜잭션의 성질)

* 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질은 4가지가 존재합니다.

### Atomicity
  * 원자성을 의미합니다.
  * 트랜잭션은 DB에 모두 반영되거나, 전혀 반영되지 않아야 한다.
  * 완료되지 않은 트랜잭션은 중간 상태를 DB에 반영하면 안된다.


### Consistency
  * 일관성을 의미합니다.
  * 트랜잭션 작업처리결과는 항상 일관성 있어야 합니다.
  * 데이터베이스는 항상 일관된 상태로 유지되어야 합니다.

### Isolation
  * 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션에 끼어들 수 없다.
  * 각각의 트랜잭션은 서로 간섭 없이 독립적으로 이루어져야 합니다.

### Durability
  * 트랜잭션이 성공적으로 완료되었다면 결과는 영구히 반영되어야 합니다.
  * 트랜잭션이 성공했더라면 시스템이 문제가 생겼더라도 반드시 반영되어야 합니다.  
  
  
  
* ACID 성질은 트랜잭션이 이론적으로 보장해야한다는 성질입니다.  

## 트랜잭션 격리 레벨의 필요성

* DB는 무결성을 보장하는게 가장 중요합니다.

  그 무결성을 보장하기 위한 특징이 위에서 설명한 ACID입니다.

  DB는 ACID가 의미하는 것처럼 트랜잭션이 원자적이면서도 독립적인 수행을 해야합니다.
  
  그로 인해 **Locking** 이 나타나게 됩니다.

* Locking


## 트랜잭션 격리 레벨

* 위의 문제의 동시성을 얻기 위한 방법입니다.
* 동시에 DB에 접근할 때 그 접근을 어떻게 제어할지에 대한 설정입니다.
* READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE_READ, SERIALIZABLE 순으로 격리 수준은 높아지지만, 성능이 떨어집니다.
* 데이터 정합성과 성능이 반비례함으로 선택을 잘해야합니다.


### READ-UNCOMMITTED

격리 수준이 가장 낮은 READ_UNCOMMITTED레벨입니다.  
한 트랜잭션이 아직 커밋되지 않은 상태임에도 불구하고 변경된 값을 다른 트랜잭션에서 읽을 수 있습니다.  

<img width="599" alt="스크린샷 2021-08-20 오후 2 08 34" src="https://user-images.githubusercontent.com/66770613/130182413-53f41f89-3556-4ecc-9dbf-7709514b1520.png">  

Dirty Read가 발생할 수 있습니다. 

```
트랜잭션 A가 트랜잭션을 끝마치지 못하고 rollback 한다면 트랜잭션 B는 무효가 된 데이터를 가지고 처리를 하기 때문에 문제가 발생할 수 있습니다.

그 뿐만 아니라, Non-Repeatable Read와 Phantom Read의 문제점도 발생합니다.
```

### READ-COMMITTED

커밋이 완료된 데이터만 다른 트랜잭션에서 조회가 가능합니다.  
트랜잭션이 이루어지는 동안 다른 사용자는 해당 데이터에 접근이 불가능합니다.  
아직 커밋하지 않은 상태라면 트랜잭션 시작 전 값을 가져오게 되고 커밋하면 변경된 데이터를 읽어올 수 있습니다.

<img width="598" alt="스크린샷 2021-08-20 오후 2 12 33" src="https://user-images.githubusercontent.com/66770613/130182680-5c6c929c-5a36-4b80-9c91-c2ec36adfc7a.png">  

Non-Repeatable Read, Phantom Read가 발생할 수 있습니다.  

```
같은 트랜잭션 내에서 SELECT를 2번 조회했는데 두 값이 다른 값이 나오는 데이터 불일치 문제입니다.
```

### REPEATABLE_READ

마찬가지로 커밋이 완료된 데이터만 읽을 수 있습니다.  
READ-COMMITED와 다른 점은 한 트랜잭션이 조회한 데이터는 트랜잭션이 종료될 때까지 다른 트랜잭션이 변경하거나 삭제하는 것을 막으므로 한 번 조회한 데이터는 반복적으로 같은 값을 반환합니다.  

<img width="599" alt="스크린샷 2021-08-20 오후 2 19 05" src="https://user-images.githubusercontent.com/66770613/130183229-838e6f7f-e534-42d8-a83c-8c6149210d46.png">  

Phantom Read가 발생할 수 있습니다.  
<img width="532" alt="스크린샷 2021-08-20 오후 2 18 00" src="https://user-images.githubusercontent.com/66770613/130183146-fa1b4cf5-fdd7-46c0-889a-b99facd5b1bc.png">  

```
Phantom Read vs Non-Repeatable Read
Phantom Read는 Non-Repeatable Read의 한 종류로 조건이 걸렸든 안 걸렸든 해당 쿼리로 읽히는 데이터에 들어가는 행위, 새로 생기거나 없어져 있는 현상입니다.
```

### SERIALIZABLE

한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근이 불가능합니다.    
트랜잭션의 ACID 성질이 강력하게 지켜지고 있으나 성능면에서 떨어집니다.  
단순한 SELECT만으로도 트랜잭션이 커밋될 때까지 모든 데이터에 잠금이 설정되어 다른 트랜잭션에서 해당 데이터를 변경할 수 없습니다.

## LOCK

여러 개의 트랜잭션이 동시에 접근했을 떄 일관성을 유지시키기 위해 잠금을 하는 것입니다.

데이터베이스는 이러한 격리 수준에 따라 트랜잭션이 실행되는 동안 각기 다른 LOCK을 걸고 데이터를 보호하고자 합니다.  
격리 수준이 높아질 수록 더 강한 LOCK을 걸게 됩니다.