---
layout: post
title: "라우팅 알고리즘(Distance vector)"
categories: 네트워크
author: bn-tw2020
---
* content
{:toc}


## 라우팅 알고리즘

* 라우터는 패킷들이 어디로 가야할지 포워딩 테이블을 통해 포워딩해준다.

* 여기서 궁금한 것은 포워딩 테이블을 누가 만들어주는 것이냐는 것이다.

* 포워딩 테이블은 라우팅 알고리즘에 의해 만들어진다.

  





* 라우팅 알고리즘는 크게 2가지로 나뉜다.

  한 가지는 네트워크 상황을 다 알고 있는 경우의 접근 방법인 **link state algorithms** 과

  다른 하나는 내 주변 근접한 이웃(라우터)들만 이야기하며 접근하는 경우는 **distance vector algorithms** 이다.


## distance vector algorithms

* link state 알고리즘은 브로드캐스트해서 직관적으로 모든 정보를 알아서 최단 경로를 찾는다.

* distance vector 알고리즘은 직접적으로 연결되어 있는 이웃과만 메시지를 교환해서 부분적인 정보를 이용해서 최단 경로를 찾는다.

<img width="537" alt="스크린샷 2021-08-28 오전 12 10 00" src="https://user-images.githubusercontent.com/66770613/131149309-648d70b1-b398-4a26-af71-3b693e4cacb8.png">  

<img width="269" alt="스크린샷 2021-08-28 오전 12 10 15" src="https://user-images.githubusercontent.com/66770613/131149346-b4337415-aa3f-4203-8421-9f2c20148f92.png">  

* dx(y)는 x에서 y로 가는 최단 거리이다.

  **x에서 y까지의 최소 경로는 무조건 x의 이웃을 통해 간다. 그리고 나머지는 이웃에서 y까지의 거리**이다.

  나머지는 이웃에서 y까지의 거리는 또 위의 방법으로 재귀적으로 이루어진다.


* 각각의 노드는 distance vector을 관리하게되고 인접한 노드들에게 받으면 최단 경로를 계산할 것이고, 

  자신의 distance vector가 변경되면 주변 노드에게 전달하면서 최신의 상태를 업그레이드 한다.

  **반드시** 자신의 distance vector에 변경이 생기면 주변 이웃 노드에게 전달하게된다.

  바뀌지 않으면 보내지않으면 된다.


<img width="775" alt="스크린샷 2021-08-28 오전 12 17 16" src="https://user-images.githubusercontent.com/66770613/131150281-f3e13c17-1bce-4c9f-90f3-3d5b53c66cd0.png">  


## 문제점

* 도중에 링크의 cost가 좋게 변화하면 금방 최적의 경로를 찾아 낼 수 있지만

  만약 cost가 않좋게 변화하게 되면, 다른 곳은 이 전에 cost로 기억하고 있기 때문에

  여러 번의 과정을 거쳐서 최적의 경로를 찾게 된다.

  이러한 문제를 count to infinity라고 부른다.

* 전체 큰 그림을 알지 못한 채 이웃에서 넘어오는 부분적인 정보를 통해 계산을 하니깐

  상대방이 보내는 distance vector가 자기 자신을 의존하는 값을 넘겨버리기 때문이다.

  그래서 의존하는 값인 경우에는 무한대라는 값을 넘겨주는 의미인 posion reverse이라는 속임수를 쓰면 된다.


##  내 • 외부 라우팅 알고리즘

* 내부 네트워크에서는 link state, distance vector 알고리즘을 이용한다.

  외부 네트워크끼리의 연결하기 위해서는 다른 알고리즘을 이용한다.

* 한국대학교에서 구글에 있는 서버에 접근하려면 게이트웨이 라우터까지는 link state 혹은 distance vector 알고리즘으로 만들어진

  포워딩 테이블을 통해 움직인다.

  한국대학교 게이트웨이 라우터에서 구글의 게이트웨이 라우터까지는 다른 알고리즘을 이용하고 구글 내부에서는 또 link state 혹은 distance vector을 이용한다.

* 내부 네트워크는 한국대학교, 구글, 네이버 등의 자치권이 있는 시스템이라고 해서 AS(Autonomous systems)라고 부른다.

  AS는 하나의 라우팅 도메인에 대한 자치권을 가진 시스템이다. 각각 AS는 AS number라는 고유의 번호를 가지고 있다.

  BBN는 1번, MIT는 3번, UCLA는 52, AT&T는 7018, 6341 ... 이런식으로 부여된다.

  AS 내부에서 동작하는 라우팅이라고 해서 **Intra-AS** 라고 부르며 AS 사이에 동작하는 라우팅 알고리즘은 **Inter-AS** 라고 부른다.


## 라우팅 프로토콜

* 인터넷에서 라우팅 프로토콜은 RIP, OSPF, BGP가 있다.

* link state을 라우팅 프로토콜로 구현한 것이 OSPF이라는 프로토콜이다.

* distance vector을 실제로 라우팅 프로토콜로 구현한 것이 RIP이다.
  
* RIP와 OSPF는 Intra AS 알고리즘이다.

* BGP(Border Gateway Protocol) 프로토콜이 현재 인터넷에서 사용하는 Inter AS 라우팅 프로토콜이다.


## 외부 라우팅 프로토콜

* 내부에서는 주체가 정해져있기 때문에 어떤 방법을 쓸지 정할 수 있다.

  하지만, 외부에서 AS끼리는 사용하는 라우팅 알고리즘은 누가 결정할지 모른다.

  그래서 UN같이 중재해주는 것이 있을까?

* Intra AS 라우팅의 목적은 최소 비용, 최단 경로이다.

* Inter AS 라우팅의 목적은 최단 경로가 목적이 아니다.

  최단 경로로 한국에서 중국으로 간다고 하면, 한국 - SK - 북한 - 중국이 최단 경로일 것이다.

  하지만, 국가적, 정치적으로 북한으로 가지 못한다. 그래서 먼길로 돌아가서 간다. 그런 것들이 혼합된 것이 BGP 프로토콜이다.

* AS들끼리도 관계가 있고, 위상이 틀리다. 미국 대통령, 엄청 작은 국가의 대통령의 위상이 다른 것이랑 비슷하다.

  AS를 만들려면 돈이 있어야한다. 하드웨어 장비, 운영비 등이 든다.

  AS는 자선단체가 아니다. 학교에서 학생들은 돈을 내고 다니면서 학교는 서비스를 제공해준다. 학교는 또 더 큰 AS로부터 돈을 내고 서비스를 받는다.

  이렇게 AS 사이는 provider, customer관계로 맺어진다.

* KT와 SKT는 서로 돈을 내고 갑, 을 관계가 아니다. 이런 경우에는 provider, customer 관계가 아닌

  peer 관계가 맺어진다.

* 이런 것들은 Link state, Distance vector 알고리즘으로는 구현이 안되고, 여러 경제, 정치, 돈과 관련이 되어있다.

<img width="798" alt="스크린샷 2021-08-28 오전 1 36 02" src="https://user-images.githubusercontent.com/66770613/131160161-052fc427-ee2c-49dd-be2e-68d8b74b1b81.png">  

<img width="798" alt="스크린샷 2021-08-28 오전 1 36 17" src="https://user-images.githubusercontent.com/66770613/131160191-45eed492-176d-41b3-a616-cfe61cb36b35.png">  
