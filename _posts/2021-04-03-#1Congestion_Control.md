---
layout: post
title: "principles of congestion control"
categories: 네트워크
author: bn-tw2020
---
* content
{:toc}


## Intro

```
네트워크를 정리하는 글입니다.
```





---

## Congestion Control

```
흐름제어(flow control)은 직관적이다. 리시버가 어느정도 보내주면 된다고 직접 알려줄 수 있기 떄문이다.
하지만 혼잡제어(congestion control)은 네트워크가 얼마나 막히고 이러한 것들을 직관적으로 알 수 없다.
물론 라우터가 알려줄 수가 있지만, 어떤 라우터가 어디가 어떤지... 복잡하기 때문이다.
    또한, 라우터는 어디로 가라고 포워딩을 해야 하는 자신의 일을 해야하기 때문이다.

혼잡제어는 쉬운 문제가 아니다. 네트워크 트래픽 자체를 알아내는 것자체가 쉽지 않습니다.
특정 상태를 따라서 짐작할 수 밖에 없습니다.
그래서 네트워크 혼잡은 delay와 loss가 발생할 수 밖에 없습니다.
```

```
실질적인 상황은 라우터에서 delay가 생겨서 패킷 유실이 일어날 수 있는데 그 패킷 유실에 대한 확실함 없이 TimeOut을 통해 알아 냅니다. 
이 경우, 실제로 도착하지 않았는데 TimeOut으로 인해 패킷을 재전송할 수 있게 됩니다.
실제로 유실되지 않는 데이터에 대해서도 재전송이 일어나게 된다는 것이다.

TimeOut이 먼저 발생하는 이유는 Congestion때문에 delay가 생기기 때문이다.
delay가 생기면 TiemOut이 먼저 생기는 것이다. 그래서 다시 데이터를 재전송하고 반복되는 것이다.
즉, 불필요한 재전송이 일어나며, 처리량도 좋아지지 않는다.
```

```
현재까지 배운 것으로 sender가 데이터를 보내는데 받음이 확정되지 않으면 계속 해서 데이터를 보냅니다.
네트워크 상황을 파악하지 않고 계속해서 보내게 됩니다.
recevier에 대한 상황은 recevier가 알려주지만, 네트워크에 대한 상황은 판단도 해야 합니다.

네트워크에 대한 상황을 판단하는 방법에는 2가지가 존재합니다.
1. end-end congestion control
    : 양쪽의 TCP 연결을 맺은 포인트끼리 네트워크 상황을 짐작하는 형태
    : 세그먼트를 전송하면 ACKs가 왔다면 중간에 유실없지 제대로 전달됨을 확인
    : ACKs가 오지 않았다면, 타임아웃이 되었다면 네트워크 상황이 좋지 않음을 확인

2. network-assistence congestion control
    : 중간에 라우터들이 알려주어 해결을 한다.
    : 라우터가 하는 일은 라우팅이기에 오버헤드가 크다.

결과적으로 짐작하는 방법은 주로 1번을 이용하며,
우선, 세그먼트를 보낸다. ACK가 오면, 잘 간 것이다.
    -> 아직까지 내가 보낼 정도는 네트워크에게 괜찮게 받을 수 있는 상태라는 것이다.
    
    세그먼트를 보낸다. TimeOut될 때까지 ACK가 안온다.
    -> 문제가 있는 것을 파악
    즉, 현재는 피드백을 가지고만 네트워크을 짐작을 한다.
```

### slow start & additive increase & multiplicative decrease

```
윈도우 사이즈만큼의 세그먼트를 보낼 것이다.
보낸 만큼의 ACK가 왔다면, 잘 도착한 것이며,
또 그 윈도우 사이즈만큼 보낼까?, 그럼 좀더 보내도 되겠다.
그럼 조금만 더 보내볼까??

윈도우 사이즈를 조금씩 늘려가면서 세그먼트를 보낸다.
잘오면 계속해서 늘려주고, 늘려주면서 보내주다가 ACK가 잘 오지 않으면..
잘 도착하지 않은 것으로 판단한다. 막히면 delay가 생기게 된다.
그래서 막혔을 때는 윈도우 사이즈를 1/2로 줄여버린다.

또 다시 천천히 올리면서 데이터를 보내게 됩니다.

최대한 많은 양을 보내주기 위함으로 네트워크 상황이 해당 세그먼트 전송량을 버틸 수 있을 만큼
적절한 양으로 보내준다. 최적의 양을 찾아가는 과정이다.
```

```
그러면, window size을 몇으로 시작하지?
네트워크는 공공의 자원이다. 모두가 만족하면서 사용해야 한다.
그래서, 한번데 다 부어버리면 마비가 발생할 수도 있다.
처음 시작하는데 네트워크의 상황도 모르니 하나 보내게 된다.(slow start)
ACK가 잘오면 2, 4, ... 2배씩 늘리면 된다.
그러다가 ssthresh(시작 한계라고 불리는 한계점)초과하면 2배씩이 아닌 하나씩 늘리면 된다. 
그러다가 네트워크 혼잡에 들어가서 패킷 유실이 발생하면 window size를 줄여주면 된다.

여기서 패킷 유실이 발생하는 경우는
1. TimeOut
2. 3duplicate ACKs
1번과 2번을 네트워크 상에서 큰 차이점이 존재한다.

3duplicate ACKs의 경우는 다른 패킷은 잘 도착했는데 특정 패킷만 운 좋지 않게 못간 것이다. 
   -> 네트워크 상황은 괜찮은데 한 패킷만 운이 나빴나 라고 생각할 것이다.
   이경우 1/2으로 줄여서 다시 하나씩 늘리면서 진행한다.
TimeOut은 3duplicate가 존재하지 않으며, ACK가 아무것도 오지 않았다는 것이다. 
   -> 내가 보낸 세그먼트가 드랍되서 죽어버린 것이다.
   이경우 다시 처음부터 slow start부터 시작한다.

   두경우 모두다 ssthreash는 반으로 줄이게된다.
```