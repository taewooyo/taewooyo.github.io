---
layout: post
title: "데이터 링크 계층(1)"
categories: 네트워크
author: bn-tw2020
---
* content
{:toc}


## 링크 계층

* 패킷을 보내면 우선 게이트웨이 라우터한테 보내진다. 그러면 포워딩해서 보내진다.

  위의 말은 개념화되어 있는 것이다.

* 게이트웨이 라우터한테 가기까지 과정을 보자. 바로 데이터 링크 계층을 보는 것이다.

  우리는 전용선이 있어서 게이트웨이 라우터까지 있는지 알았지만, 사실은 공유하는 채널이 존재한다.


* 공유하는 매체에 패킷을 올리게되면, 시그널로 변환되서 모든 방향으로 퍼지면서 게이트웨이 라우터가 받는 것이다.

  시그널이 동시에 같이 이야기를 하게 된다면, 섞이게 되면서 collision이 발생하고
  
  충돌이 발생하면 신호가 섞이고, 무슨 말인지 이해못하고 게이트웨이 입장에서는 쓰레기로 들리게 되면서 낭비가 된다.

* 우리는 충돌을 발생하지 않게, 해결해야 한다.





## 링크 계층 개요

* 링크 레이어는 한 hop에 대한 이야기이다. 한 hop을 어떻게 충돌나지 않게 잘 보낼까라고 생각하면 된다.

* 무선, 유선이든 기본적으로 브로트캐스트 미디어이다. 어떻게 충돌나지 않게 사용할까를 생각하는 것이다.

* 전송 계층, 네트워크 계층은 운영체제 내부에 소프트웨어로 구현되어있다.

  링크 계층은 NIC에 구현되어있다.

<img width="369" alt="스크린샷 2021-08-28 오전 1 52 51" src="https://user-images.githubusercontent.com/66770613/131162073-5f10f098-30bc-4eb8-a55e-03f6ae42525a.png">  

<img width="570" alt="스크린샷 2021-08-28 오전 1 53 28" src="https://user-images.githubusercontent.com/66770613/131162140-ca4e6008-e9aa-44c1-85b1-8242fc50229b.png">  



## Multiple access links

* 만약 host와 host가 전용선으로 연결되어 있다면, 데이터를 보내면 아무런 충돌이 없을 것이다.

  하지만, 많은 사람들이 공유하는 채널을 가진 링크를 사용한다.

  그래서, 어느 한 군데서 패킷을 보내면 시그널이 퍼지게 된다. 다 퍼지기 때문에 이 매체를 broadcast medium이라고 한다.

  우리가 많은 곳에서 말하는 것은 공기가 브로트캐스트 매체가 된다.

* 매체에 접근을 할 때, 접근하는데 조절해서 충돌을 해결하고자 하는 것이 **Medium Acess Control; MAC Protocol** 이 있다.

```
1. 한 노드가 데이터를 전송하고 싶을 때는 온전히 R bandwidth을 사용할 수 있으면 좋다.
2. N개의 노드가 보내고 싶다면 N등분해서 사용하면 좋다.
3. 분산처리되면 좋을 것 같고 단순하면 좋겠다.
```

위의 방법을 성공시키고자 여러 MAC 프로토콜의 제안이 되었다. 그 중 channel partitioning, random access, taking turns가 있다.


## Channel partitioning protocol

* TDMA(Time division multiple access)

  시간을 쪼개서 여러 사람들이 접근할 수 있게 하는 것이다.
  
  각 사람별로 각자 자기 자신이 전송할 수 있는 타임 슬롯을 할당해서 자기차례가 오면 보내는 것이다.

  하지만, 자원이 낭비되는 문제가 있다.

* FDMA(frequency division multiple access)

  각자 자기 자신의 주파수가 정해져있어서 그 주파수를 보내는 것이다.

  TDMA와 같이 장단점이 같다.


## Random access protocol

* 내가 보내고자 할 데이터가 있을 때 데이터를 보내는 것이다.

  이것은 충돌이 발생한다.

  여기서는 충돌을 어떻게 감지하여 해결할 것인가가 중요한 타겟이다.

* **CSMA(Carrier Sense Multiple Access)**

  사람 3명이 술을 마시러 술집에 갔다. 말을 할 때 동시에 말하지 않으려고 눈치보면서 듣고 있다가 이야기한다.

  CSMA는 listen before transmit이다.

* 이렇게 하게 되면, 충돌이 안날까?

  듣고있다가 어 말해도 되겠다하고 2명이 동시에 말하게 되면 충돌하게 된다.

<img width="377" alt="스크린샷 2021-08-28 오전 2 19 54" src="https://user-images.githubusercontent.com/66770613/131165204-2e86a2e7-dd46-4535-9fba-413dc9f69781.png">  

* 위의 그림을 보게되면, 2번은 전송을 했는데 4번은 2번의 데이터를 듣는데 시간이 있기 때문에 4번은 2번이 말한지 모르고 말을 할 수가 있다.

  그러면, 중간에 충돌이 발생에 엉망이 되버린다.

  데이터를 전송했는데 한번에 팍 도착한다면 충돌이 나지 않을 것이다. 이 말은 전달지연(Propagation delay)이 없다는 것인데

  전달 지연을 아예 0을 만들면 되지만 빛의 속도이기 때문에 만들 수 가 없다. 그래서 CSMA를 쓰면 충돌이 발생한다.

* 위의 방법은 충돌이 났는데도 서로 데이터를 전송하는 경우이다. 실생활에서 사람들이 서로 동시에 말했는데 멈추지 않고 계속해서 자기 말 만하는 것이다.
  
  하지만, 현실은 동시에 말하면 겹치는 것을 감지하고 멈춘다.

* 여기서 멈추고 다시 새로운 데이터를 보내는 방법이 CSMA를 개선한 **CSMA/CD** 이다.

  즉, listen before transmit인데, 충돌을 감지하면 바로 전송을 멈추는 것이다.

<img width="398" alt="스크린샷 2021-08-28 오전 2 09 51" src="https://user-images.githubusercontent.com/66770613/131164088-4de0d3b4-7385-4319-846f-07eff56afa3b.png">  

* 멈춘 다음은 어떻게 진행되는 것인가?

  누가 먼저 말하고 누가 기다릴 것인지는 중재가 있으면 편하다. 실제 토크쇼에서도 사회자가 있듯이 말이다. 하지만 링크 계층에는 중재가 없다. 

  멈추 후에는, **binary(exponential) backoff** 을 한다. 

* binary backoff은 충돌이 발생하여 재전송할 때에 충돌했던 것끼리 재충돌 확률을 줄이기 위해서 재전송을 위해 기다리는 시간들을 랜덤하게 결정하는 것이다.

  n번의 충돌이 있다면 {0, 1, 2, ... (2^n) -1} 하나를 랜덤하게 골라서 기다리는 것이다.
  
* 이 방식은 충돌이 계속 해서 발생하면 오래 기다리게 되는데 왜 그럴까?

  충돌이 났다는 것은 누가 나랑 같이 충돌 났다고 인지하고 있는 것이다. 하지만 몇명인지 모른다.

  만약에 이야기 하자고 하는 사람이 적다면 오래 기다릴 필요가 없으니 작게 해서 고르면 되지만, 
  
  이야기 하고자 하는 사람이 10명이 인데 4개 중에서 고르면 또 충돌이 난다. 즉, 각자 다른 숫자를 골라야한다.

  충돌이 나면 아 지금 이야기하고자 하는 사람이 많구나 라는 생각으로 늘려나가게 된다.

* backoff시간이 커지면 delay가 커지는 것이다. 

  backoff 시간은 충돌이 많을 때 커진다. 사람들이 많을 때다.

  그래서 사람들이 많을 때 체감 상 네트워크가 늦어지는 이유는 네트워크 상의 문제보단 backoff의 지연 시간으로 생각하는 게 맞다.


## Taking turns protocol

* 중간 과정에 중재자를 두는 방식이다.

* Polling 방식은 master을 둬서 물어보는 것이다.

  하지만, 단점으로 master가 죽으면 끝나버린다.

* Token passing은 방식은 토큰을 가지고 있는 호스트만이 데이터를 전송할 수 있는 것이다.

  이것의 문제는 토큰을 잃어버리게 되면 망한다.

* 위의 방식을 주로 잘 이용되지 않는다.

