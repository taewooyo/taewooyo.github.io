---
layout: post
title: "[QnA] 물리적 데이터베이스 설계"
categories: DB
author: bn-tw2020
---
* content
{:toc}


## 물리적 데이터베이스 설계

* 물리적 데이터베이스 설계는 파일 구조와 운영체제 부분과 많은 관련이 있습니다.

* 논리적인 설계의 데이터 구조를 보조 기억 장치상의 파일(물리적인 데이터 모델)로 사상합니다.

* 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션들을 분석합니다.

* 데이터에 대한 효율적인 접근을 제공하기 위하여 저장 구조와 접근 방법들을 다룹니다.

* 특정 DBMS의 특성을 고려하여 진행됩니다.

* 질의를 효율적으로 지원하기 위해서 **인덱스 구조**를 적절히 사용합니다.





## 보조 기억 장치

* 데이터들은 보조기억장치에 저장되어 있습니다. 현재는 플래시 메모리에도 저장하며 사용중에 있습니다.

* 사용자가 원하는 데이터를 검색하기 위해서 DBMS는 디스크 상의 데이터베이스로부터 사용자가 원하는 데이터를 포함하고 있는

  블록을 읽어서 주기억장치로 가져옵니다.

* **데이터가 변경된 경우에는 블록들을 디스크에 다시 기록합니다.**

  주기억장치는 휘발성 메모리라 날라가면 데이터 무결성에 위배될 것입니다.

  블록크기는 512Byte ~ 수 킬로바이트까지 다양합니다. 일반 전형적인 블록 크기는 4096Byte입니다.

* 각 파일은 곡정된 크기의 블록들로 나누어져서 저장됩니다.

* 디스크는 데이터베이스를 장기간 보관하는 주된 보조기억장치라고 부릅니다.

> 자기 디스크

* 디스크는 자기 물질로 만들어진 여러 개의 판으로 이루어집니다.
  
  각 면마다 디스크 헤드가 있습니다. 각 판마다 **트랙** 과 **섹터**로 구분됩니다.

* 정보는 디스크 표면 상의 트랙을 따라 저장됩니다.

* 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들을 실린더라고 부릅니다.

* 블록은 한 개 이상의 섹터들로 이루어집니다.

* 디스크에서 임의의 블록을 읽어오거나 기록하는 걸리는 시간은 탐구시간, 회전 지연 시간, 전송 시간의 합으로 이루어집니다.


## 버퍼 관리와 운영체제

* 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업이므로 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상하는데 매우 중요합니다.

  가능하면 많은 블록들을 주기억 장치에 유지하거나, 자주 참조되는 블록들을 주기억장치에 유지하면 블록 전송 횟수를 줄일 수 있습니다.

* **버퍼**는 디스크 블록들을 저장하는데 사용되는 주기억 장치 공간입니다.

* 버퍼 관리자는 운영 체제의 구성요소로서 주기억 장치 주기억 장치 내에서 버퍼 공간을 할당하고 관리하는 일을 맡습니다.

* 운영 체제에서 버퍼 관리르 위해 흔히 사용되는 LRU 알고리즘은 데이터베이스를 위해 항상 우수한 성능을 보이지는 않습니다.


## 디스크 상에서 파일의 레코드 배치

* 릴레이션의 애트리뷰트는 고정 길이 or 가변 길이로 표현 된다.

  연관된 필드들이 모여서 고정 길이 or 가변 길이의 레코드가 된다.

* 한 릴레이션의 구성하는 레코드들의 모임이 파일이라고 부르는 블록들의 모임에 저장된다.

* 한 파일의 속하는 블록들이 반드시 인접해 있을 필요는 없습니다.

  인접한 블록들을 읽는 경우에는 탐구 시간과 회전 지연시간이 들지 않기 때문에 입출력 속도가 빠르므로

  블록들이 인접하도록 한 파일의 블록들을 재조직 할 수 있습니다.

* 실제로는 떨어져 있는 경우가 있어서 같은 파일에 있는지 어떻게 아는지는 링크드 리스트로 구현 되어있습니다.

<img width="382" alt="스크린샷 2021-08-20 오후 9 09 55" src="https://user-images.githubusercontent.com/66770613/130230988-8ffa29e6-268f-4d02-8960-194998849ebe.png">  

> 파일 내의 클러스터링

* 한 파일 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 모아두는 것

> 파일 간의 클러스터링

* 함께 검색될 가능성이 높은 2개 이상의 파일에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것


## 파일 조직의 유형

> 히프 파일

* 가장 단순한 파일 조직

  일반적으로 레코드들이 삽입된 순서대로 파일에 저장된다.

* 삽입 : 새로 삽입되는 레코드는 파일의 가장 끝에 저장된다.

  검색 : 원하는 레코드를 찾기 위해서는 모든 레코드들을 순차적으로 접근해야 한다.

  삭제 : 원하는 레코드를 찾은 후에 그 레코드를 삭제하고, 삭제된 레코드가 차지하던 공간을 재사용하지 않는다.

* 좋은 성능을 유지하기 위해 히프 파일을 재조직할 필요가 있다.


> 순차 파일

* 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 파일

  레코드들이 일반적으로 레코드의 **탐색 키** 값의 순서에 따라 저장됩니다.

* 탐색 키는 순차 파일을 정렬하는데 사용되는 필드를 의미한다.

* 삽입 : 삽입하려는 레코드의 순서를 고려해야 하기에 시간이 많이 걸릴 수 있다.

  삭제 : 삭제된 레코드가 사용하던 공간을 빈 공간으로 남기기 때문에 히프 파일과 같이 주기적인 재조직이 필요하다.

* 기본 인섹스가 순차 파일에 정의되지 않는 한 순차 파일은 데이터베이스 응용을 위해 거의 사용 하지 않는다.

* **단점**으로 탐색 키 기준으로는 이진탐색이 가능하지만, 다른 필드로 검색하게 되면 저장 순서와 무관하기에 파일 전체를 탐색해야 합니다.


> 단일 단계 인덱스

* 인덱스된 순차 파일은 인덱스를 통해서 임의의 레코드를 접근할 수 있는 파일

* 단일 단계 인덱스의 간 엑트리는 **<탐색 키, 레코드에 대한 포인터>**

  인덱스를 만들 때는 어떤 애트리뷰트를 사용할지 결정해야 한다. 그 애트리뷰트를 탐색 키가 된다.

* 엔트리들은 탐색 키 값의 오름차순으로 정렬된다.

* 인덱스는 데이터 파일과는 별도의 파일에 저장된다.

  인덱스의 크기는 데이터 파일의 크기에 비해 훨씬 작다.

  하나의 파일에 여러 개의 인덱스를 정의할 수 있다.

<img width="289" alt="스크린샷 2021-08-20 오후 10 01 12" src="https://user-images.githubusercontent.com/66770613/130237086-7fe76005-0bc1-4a03-8c27-0d77b86ec9c5.png">  

* 인덱스가 정의된 필드를 **탐색 키** 라고 위에서 정의되어있습니다.

  탐색 키의 값들은 후보 키처럼 각 투플마다 반드시 고유하지 않다.

  키를 구성하는 애트리뷰트뿐만 아니라 어떤 애트리뷰트도 탐색 키로 사용될 수 있다.

  도메인 카디널리티가 적은 것을 탐색 키로 잡는 것은 바람직하지 않다.

*  인덱스의 엔트리들은 탐색 키 값의 오름차순으로 저아도이어 있으므로 이진 탐색으로 이용할 수 있다.

<img width="171" alt="스크린샷 2021-08-20 오후 10 12 50" src="https://user-images.githubusercontent.com/66770613/130238526-b3d4bf88-9aa5-4a70-8b79-d94c79d896c3.png">  


## 기본 인덱스

* 탐색 키가 데이터 파일의 기본 키인 인덱스를 기본 인덱스라고 부릅니다.

* 기본 인덱스는 기본 키의 값에 따라 정렬된 데이터 파일에 대해 정의됩니다.

  흔히 희소 인덱스로 유지할 수 있습니다. 데이터 파일의 자체 기본 키가 정렬되어 있다면 희소 인덱스로 만들 수 있다.

  각 레코드의 키 값에 대해서 인덱스에 엔트리로 인덱스
  
  희소 인덱스는 데이터 파일을 구성하는 각 블록마다 하나의 탐색 키 값이 인덱스 엔트리에 포함합니다.

*  각 릴레이션마다 최대한 한 개의 기본 인덱스를 가질 수 있다.

<img width="399" alt="스크린샷 2021-08-20 오후 10 29 17" src="https://user-images.githubusercontent.com/66770613/130240644-8e97cd18-064e-4351-9c36-85c03a609cfe.png">  


## 보조 인덱스

* 한 파일은 기껏해야 한 가지 필드들의 조합에 대해서만 정렬될 수 있습니다.

* 보조 인덱스는 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다.

  일반적으로 밀집 인덱스이므로 같은 수의 레코드들을 접근할 때 보조 인덱스를 통하면 
  
  기본 인덱스를 통하는 경우보다 디스크 접근 횟수가 증가할 수 있습니다.


## 클러스터링 인덱스

* 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의된다.

* 각각의 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함된다.

* 범위 질의에 유용하다.

  범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고, 범위에 속하는 인덱스 엔트리들을 따라가면서

  레코드들을 검색할 때 디스크에서 읽어오는 블록 수가 최소화된다.

* 어떤 인덱스 엔트리에서 참조되는 데이터 블록을 읽어오면 그 데이터 블록에 들어 있는 대부분의 레코드들은 범위를 만족한다.

* 테이블 자체가 인덱스입니다. (클러스터링 인덱스를 기준으로 테이블을 정렬하기 때문)

<img width="420" alt="스크린샷 2021-08-20 오후 11 04 09" src="https://user-images.githubusercontent.com/66770613/130245467-72ee033e-4cf7-41c3-a32b-2f3c0763547c.png">  


## 넌 클러스터링 인덱스

* 인덱스 페이지를 별도도 저장합니다.

* 인덱스 페이지는 로그 파일로 저장하며, 레코드의 원본은 정렬되지 않으며, 인덱스 페이지만 정렬됩니다.

* 인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 만들기에 용량을 더 차지한다.

* 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 포인터이기 때문에 클러스터형보다 검색 속도가 느리지만,

  데이터의 입력, 수정, 삭제는 빠르다.


## 다단계 인덱스

* 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸릴 수도 있습니다.

* 인덱스 엔트리를 탐색하는 시간을 줄이기 위해서 단일 단계 인덱스를 디스크 상의 하나의 순서 파일로 간주하고,

  단일 단계 인덱스에 대해서 다시 인덱스를 정의할 수 있다.

* 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복합니다.

* 가장 상위 단계 인덱스를 **마스터 인덱스** 라고 부릅니다.

  마스터 인덱스는 한 블록으로 이루어지기 때문에 주기억 장치에 상주할 수 있다.

  대부분의 다단계 인덱스는 **B+-트리** 를 사용합니다.

## 인덱스의 장점

* 인덱스는 검색 속도를 향상시키지만, 인덱스를 저장하기하기 위한 공간이 추가로 필요하다.

  삽입, 삭제, 수정 연산의 속도는 저하시킨다.

* 소수의 레코드들을 수정하거나 삭제하는 연산의 속도는 향상된다.

* 릴레이션이 매우 크고, 질의에서 릴레이션의 투플들 중에 일부(2% ~ 4%)를 검색하고

  WHERE절이 잘 표현되었을 때 특히 성능에 도움이 된다.


## 인덱스가 사용되지 않는 곳

* 시스템 카탈로그가 오래 전의 데이터베이스 상태를 나타냅니다.

  DBMS의 질의 최적화 모듈이 릴레이션의 크기가 작아서 인덱스가 도움이 되지 않된다.


## 인덱스 선점 지침

```
1. 기본 키는 클러스터링 인덱스를 정읭할 훌륭한 후보
2. 외래 키도 인덱스를 정의할 중요한 후보
3. 한 애트리뷰트에 들어 있는 상이한 값들의 개수가 거의 전체 레코드 수와 비슷하고,
   그 애트리뷰트가 동등 조건에서 사용된다면 넌 클러스터링 인덱스를 생성하는 것이 좋다.
4. 투플이 많이 들어 있는 릴레이션에서 대부분의 질의가 검색하는 투플이 2% ~ 4% 미만인 경우에는 인덱스를 생성
5. 자주 갱신되는 애트리뷰트에는 인덱스 정의하지 않는 것이 좋다.
6. 갱신이 빈번하게 이루어지는 릴레이션에는 인덱스를 많이 만드는 것을 피한다.
7. 후보 키는 기본 키가 갖는 모든 특성을 마찬가지로 갖기 때문에 인덱스를 생성할 후보
8. 인덱스는 파일의 레코드들을 충분히 분할할 수 있어야 한다.
9. 정수형 애트리뷰트에 인덱스를 생성
10. varchar 애트리뷰트에는 인덱스를 만들지 않는다.
11. 작은 파일에는 인덱스를 만들 필요가 없다.
12. 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고, 데이터 삽입이 끝난 후에 인덱스들을 다시 생성하자
13. ORDER BY, GROUP BY절에 자주 사용되는 애트리뷰트는 인덱스를 정의할 후보
```


## Ref

[B+-Tree](https://goneill.co.nz/btree-demo.php)