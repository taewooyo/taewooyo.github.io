---
layout: post
title: "[QnA] 물리적 데이터베이스 설계"
categories: DB
author: bn-tw2020
---
* content
{:toc}


## 물리적 데이터베이스 설계

* 물리적 데이터베이스 설계는 파일 구조와 운영체제 부분과 많은 관련이 있습니다.

* 논리적인 설계의 데이터 구조를 보조 기억 장치상의 파일(물리적인 데이터 모델)로 사상합니다.

* 예상 빈도를 포함하여 데이터베이스 질의와 트랜잭션들을 분석합니다.

* 데이터에 대한 효율적인 접근을 제공하기 위하여 저장 구조와 접근 방법들을 다룹니다.

* 특정 DBMS의 특성을 고려하여 진행됩니다.

* 질의를 효율적으로 지원하기 위해서 **인덱스 구조**를 적절히 사용합니다.


## 보조 기억 장치

* 데이터들은 보조기억장치에 저장되어 있습니다. 현재는 플래시 메모리에도 저장하며 사용중에 있습니다.

* 사용자가 원하는 데이터를 검색하기 위해서 DBMS는 디스크 상의 데이터베이스로부터 사용자가 원하는 데이터를 포함하고 있는

  블록을 읽어서 주기억장치로 가져옵니다.

* **데이터가 변경된 경우에는 블록들을 디스크에 다시 기록합니다.**

  주기억장치는 휘발성 메모리라 날라가면 데이터 무결성에 위배될 것입니다.

  블록크기는 512Byte ~ 수 킬로바이트까지 다양합니다. 일반 전형적인 블록 크기는 4096Byte입니다.

* 각 파일은 곡정된 크기의 블록들로 나누어져서 저장됩니다.

* 디스크는 데이터베이스를 장기간 보관하는 주된 보조기억장치라고 부릅니다.

> 자기 디스크

* 디스크는 자기 물질로 만들어진 여러 개의 판으로 이루어집니다.
  
  각 면마다 디스크 헤드가 있습니다. 각 판마다 **트랙** 과 **섹터**로 구분됩니다.

* 정보는 디스크 표면 상의 트랙을 따라 저장됩니다.

* 여러 개의 디스크 면 중에서 같은 지름을 갖는 트랙들을 실린더라고 부릅니다.

* 블록은 한 개 이상의 섹터들로 이루어집니다.

* 디스크에서 임의의 블록을 읽어오거나 기록하는 걸리는 시간은 탐구시간, 회전 지연 시간, 전송 시간의 합으로 이루어집니다.


## 버퍼 관리와 운영체제

* 디스크 입출력은 컴퓨터 시스템에서 가장 속도가 느린 작업이므로 입출력 횟수를 줄이는 것이 DBMS의 성능을 향상하는데 매우 중요합니다.

  가능하면 많은 블록들을 주기억 장치에 유지하거나, 자주 참조되는 블록들을 주기억장치에 유지하면 블록 전송 횟수를 줄일 수 있습니다.

* **버퍼**는 디스크 블록들을 저장하는데 사용되는 주기억 장치 공간입니다.

* 버퍼 관리자는 운영 체제의 구성요소로서 주기억 장치 주기억 장치 내에서 버퍼 공간을 할당하고 관리하는 일을 맡습니다.

* 운영 체제에서 버퍼 관리르 위해 흔히 사용되는 LRU 알고리즘은 데이터베이스를 위해 항상 우수한 성능을 보이지는 않습니다.


## 디스크 상에서 파일의 레코드 배치

* 릴레이션의 애트리뷰트는 고정 길이 or 가변 길이로 표현 된다.

  연관된 필드들이 모여서 고정 길이 or 가변 길이의 레코드가 된다.

* 한 릴레이션의 구성하는 레코드들의 모임이 파일이라고 부르는 블록들의 모임에 저장된다.

* 한 파일의 속하는 블록들이 반드시 인접해 있을 필요는 없습니다.

  인접한 블록들을 읽는 경우에는 탐구 시간과 회전 지연시간이 들지 않기 때문에 입출력 속도가 빠르므로

  블록들이 인접하도록 한 파일의 블록들을 재조직 할 수 있습니다.

* 실제로는 떨어져 있는 경우가 있어서 같은 파일에 있는지 어떻게 아는지는 링크드 리스트로 구현 되어있습니다.

<img width="382" alt="스크린샷 2021-08-20 오후 9 09 55" src="https://user-images.githubusercontent.com/66770613/130230988-8ffa29e6-268f-4d02-8960-194998849ebe.png">  

> 파일 내의 클러스터링

* 한 파일 내에서 함께 검색될 가능성이 높은 레코드들을 디스크 상에서 물리적으로 모아두는 것

> 파일 간의 클러스터링

* 함께 검색될 가능성이 높은 2개 이상의 파일에 속한 레코드들을 디스크 상에서 물리적으로 가까운 곳에 저장하는 것


## 파일 조직의 유형

> 히프 파일

* 가장 단순한 파일 조직

  일반적으로 레코드들이 삽입된 순서대로 파일에 저장된다.

* 삽입 : 새로 삽입되는 레코드는 파일의 가장 끝에 저장된다.

  검색 : 원하는 레코드를 찾기 위해서는 모든 레코드들을 순차적으로 접근해야 한다.

  삭제 : 원하는 레코드를 찾은 후에 그 레코드를 삭제하고, 삭제된 레코드가 차지하던 공간을 재사용하지 않는다.

* 좋은 성능을 유지하기 위해 히프 파일을 재조직할 필요가 있다.


> 순차 파일

* 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 파일

  레코드들이 일반적으로 레코드의 **탐색 키** 값의 순서에 따라 저장됩니다.

* 탐색 키는 순차 파일을 정렬하는데 사용되는 필드를 의미한다.

* 삽입 : 삽입하려는 레코드의 순서를 고려해야 하기에 시간이 많이 걸릴 수 있다.

  삭제 : 삭제된 레코드가 사용하던 공간을 빈 공간으로 남기기 때문에 히프 파일과 같이 주기적인 재조직이 필요하다.

* 기본 인섹스가 순차 파일에 정의되지 않는 한 순차 파일은 데이터베이스 응용을 위해 거의 사용 하지 않는다.

* **단점**으로 탐색 키 기준으로는 이진탐색이 가능하지만, 다른 필드로 검색하게 되면 저장 순서와 무관하기에 파일 전체를 탐색해야 합니다.


> 단일 단계 인덱스

* 인덱스된 순차 파일은 인덱스를 통해서 임의의 레코드를 접근할 수 있는 파일

* 단일 단계 인덱스의 간 엑트리는 **<탐색 키, 레코드에 대한 포인터>**

  인덱스를 만들 때는 어떤 애트리뷰트를 사용할지 결정해야 한다. 그 애트리뷰트를 탐색 키가 된다.

* 엔트리들은 탐색 키 값의 오름차순으로 정렬된다.

* 인덱스는 데이터 파일과는 별도의 파일에 저장된다.

  인덱스의 크기는 데이터 파일의 크기에 비해 훨씬 작다.

  하나의 파일에 여러 개의 인덱스를 정의할 수 있다.

<img width="289" alt="스크린샷 2021-08-20 오후 10 01 12" src="https://user-images.githubusercontent.com/66770613/130237086-7fe76005-0bc1-4a03-8c27-0d77b86ec9c5.png">  

* 인덱스가 정의된 필드를 **탐색 키** 라고 위에서 정의되어있습니다.

  탐색 키의 값들은 후보 키처럼 각 투플마다 반드시 고유하지 않다.

  키를 구성하는 애트리뷰트뿐만 아니라 어떤 애트리뷰트도 탐색 키로 사용될 수 있다.

  도메인 카디널리티가 적은 것을 탐색 키로 잡는 것은 바람직하지 않다.

*  인덱스의 엔트리들은 탐색 키 값의 오름차순으로 저아도이어 있으므로 이진 탐색으로 이용할 수 있다.

<img width="171" alt="스크린샷 2021-08-20 오후 10 12 50" src="https://user-images.githubusercontent.com/66770613/130238526-b3d4bf88-9aa5-4a70-8b79-d94c79d896c3.png">  


## 기본 인덱스

* 탐색 키가 데이터 파일의 기본 키인 인덱스를 기본 인덱스라고 부릅니다.

* 기본 인덱스는 기본 키의 값에 따라 정렬된 데이터 파일에 대해 정의됩니다.

  흔히 희소 인덱스로 유지할 수 있습니다. 데이터 파일의 자체 기본 키가 정렬되어 있다면 희소 인덱스로 만들 수 있다.

  전체 탐색 키를 인덱스로 만드는 것을 밀집 인덱스라고 부르며 
  
  희소 인덱스는 데이터 파일을 구성하는 각 블록마다 하나의 탐색 키 값이 인덱스 엔트리에 포함합니다.

*  각 릴레이션마다 최대한 한 개의 기본 인덱스를 가질 수 있다.

<img width="399" alt="스크린샷 2021-08-20 오후 10 29 17" src="https://user-images.githubusercontent.com/66770613/130240644-8e97cd18-064e-4351-9c36-85c03a609cfe.png">  



